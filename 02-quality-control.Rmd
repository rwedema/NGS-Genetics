# Data and quality control {#quality-control}

For this project we have patient data from patients suspectedly suffering from either Cardiomyopathy or Medulloblastoma you will be investigating. The patient data consists of next-generation Illumina reads (MiSeq or NextSeq) from captured exomes for a panel of a given size (small number of genes). For example, when looking at the gene panel used to diagnose the heart disease cardiomyopathy, there is sequence data available on "only" 55 genes out of the 26k genes. (CARDIO panel, see table and the [NCBI](https://www.ncbi.nlm.nih.gov/gtr/tests/GTR000500470/overview/) product page - note that it only lists 51 of them) which are likely involved in the disease. The total length of the captured exons for these 55 genes is about 320,000 bases. Which, again, is just a very small fraction of the complete exome lenght.

The first step will be a thorough quality check of the available data, for which we first need to take a close look at the data format being used.

```{r, echo=FALSE}
knitr::include_graphics("images/genepanel.png")
```

## FASTQ format

As mentioned before, a great portion of the data produced in computational biology is from so called *Next-Generation Sequencers*. These machines read DNA or RNA material and write these sequences to a file (the different machines and techniques used to create such data will be presented during the Theory of Bioinformatics classes).

A file format that you will often find is the [**FASTQ**](https://en.wikipedia.org/wiki/FASTQ_format) format. You can recognize such a file by it's extention **.fastq** or **.fq**. A FASTQ file is a simple text file in which the read bases together with the predicted quality are stored.

Below you will find two (shortened) reads coming from an Illumina next-generation sequencer. Keep in mind that a typical run on a NGS machine has *millions* of these short sequences! This theoretical maximum number of reads of a given size is determined by the underlying technique used, which greatly differs between the different techniques.

**Read 1**:

::: rmdnote
<font color="red">\@M01785:20:000000000-A3F6F:1:1101:16810:1655 1:N:0:2</font> <font color="blue">NTCATGTACGGTCAGGATGGACGCACTCAACATTTTCAAGTTATTACTCCTTCAACTCAAAACT</font> ... <br /> `+` <font color="green"><br />#\>\>1A1B3B11BAEFFBECA0B000EEGFCGBFGGHH2DEGGHGFFFGFFHHFGBGEFFFFF</font> ...
:::

**Read 2**:

::: rmdnote
<font color="red">\@M01785:20:000000000-A3F6F:1:1101:12839:1664 1:N:0:2</font> <font color="blue"> TATATCTATGTCATTTTTTTCTCAATAATACTAAGAGAAAGAAGGCAACTCAAGGATCCTATTAATCCTTTA</font> ... <br /> `+` <br /> <font color="green">1\>1AFFFD3DDDGGGGGGGGGHF3FDFGFHHFB1110FF10000FGGGHHDC110FEGGBGHFFHFHHHHGBFH</font> ...
:::

Each read constists of:

<ul>
  <li> <font color="red">A first line describing the machine it was run on, the chip identifier and the actual coordinates from the chip where the base was read</font>
  <li> <font color="blue">The actual read sequence</font>
  <li>The plus sign
  <li> <font color="green">The predicted read base quality ASCII value</font>
</ul>

The difference with the widely known [FASTA](https://en.wikipedia.org/wiki/FASTA_format) format is mainly the addition of the **Quality** line (green). So, given these quality-characters, how do we determine if the above sequences are *good* sequences? Each character in the quality line corresponds with a numerical quality [*score*](https://en.wikipedia.org/wiki/Phred_quality_score), which can be looked up in so called ASCII tables.

Note: can you think of why this intermediate ASCII table is used to calculate quality scores?

Lets take a closer look at the first sequence from above. The first 10 bases are: `NTCATGTACG` and the quality scores for these bases are: `#>>1A1B3B1`. We can now look up these quality characters in the ASCII table.

```{r, echo=FALSE, out.width="70%"}
knitr::include_graphics("images/ASCII.png")
```

If we look for example at the first character `#`, we find the value **35** in the ASCII table. For *Illumina* reads we have to subtract 33 (this is called the offset, and different techniques may use a different offset) from this value. So we end up with: 35 - 33 = 2. So the score for the first base N is **2**. This score is called the *Phred* score. Lets also look at the Phred score for the second base T which has the ASCII character `>`. The `>` character translates to the value **62**. Again subtract 33 from this value to calculate the Phred score. 62 - 33 = **29**.

What does the Phred quality score really mean? The score indicates the *probability that the base call is erroneous*. The quality score Q is logarithmically related to the probability of an incorrect base call: $$ Q = log10P $$ or $$ P = 10^{(-Q/10)} $$. To calculate the probability that our first base was incorrectly called, we can calculate it like this: $$ Q = 2 \rightarrow P = 10^{(-2/10)} \rightarrow P = 0,63 $$

which equates to **63%**. We can also look for the probability that the first base was *correct*, then we have to subtract that number of 1. So the probability that the first base was correct is: $$ 1 - 0,63 = 0,37 $$ or 37%. The probability the second base was correctly called is: $$ 1 -
(10^{-29/10}) = 0,9987 $$ or 99,87% accuracy. In general we can say that any *Phred-score* above 30 is acceptable (a 99,9% accuracy) which both the first two bases fail to get.

Complete the table below.

|                                  |     |        |     |     |     |     |     |     |     |     |
|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|
| Base                             | N   | T      | C   | A   | T   | G   | T   | A   | C   | G   |
| Quality char                     | \#  | \>     | \>  | 1   | A   | 1   | B   | 3   | B   | 1   |
| Numerical score ASCII value - 33 | 2   | 29     |     |     |     |     |     |     |     |     |
| Base call accuracy 1 - P         | 37% | 99,87% |     |     |     |     |     |     |     |     |

## Quality Control

We need to load the patient data you are going to work on during this project. All patient data is stored on the network and you first need to load it into your Galaxy <strong>History</strong> to work with. To do this click on the 'Upload Data' button and next on the 'Choose local files' button at the bottom of the popup. Here, you can browse to the folder on the network that contain all samples which is: `/students/2024-2025/minor/genomics-data`. Note that for Cardiomyopathy, use the `CM-DNASeq` folder and for Medulloblastoma, use the `MB-DNASeq` folder.

As you can see each case consists of two files. This is because the forward and reverse reads are split up into two files (*paired-end sequencing*). The files with **R1** or **\_1** in the name are the forward reads and the reverse reads have **R2** or **\_2** in their name, remember this as some tools require to select the proper file.

If for example `Medulloblastoma` is your disease case, you can select both read files from a `Medulloblastoma` sample, such as `SRR29613194`. Galaxy automatically tries to detect the file format that you will add to a history, most often using it's file extension. In this case, we need to make sure that Galaxy has the proper format selected which is `fastqsanger`. The Sanger part of this format refers to the *phred quality scoring* method used in this file as there exist multiple scoring methods. Without the correct data type a tool such as `FastQC` (see below) doesn't know when a read is of sufficient quality or worse, qualifies reads incorrectly. Select the proper type from the drop-down menu and upload the files.

After you have uploaded the sequence data in your history, it is available to work on. If all went correct, you should now see the two sequence files in your History of Galaxy.

```{r, echo=FALSE, fig.align="center", out.width="80%"}
knitr::include_graphics("images/historyPatient.png")
```

When you start to analyse NGS data it is very important to get a feeling for the data. What does the data look like? What is the quality of my data? You do not (although you *can*) want to draw conclusions on low quality data. For some common errors the data can be corrected. To be able to do so, you would first need to identify what is wrong with the data. To look at many (quality) aspects of our imported data sets, we are going to start a tool named [**FastQC**](http://www.bioinformatics.babraham.ac.uk/projects/fastqc/). In the <strong>Tools</strong> panel, search for the <strong>FastQC</strong> tool (can also be found under the `FASTQ Quality Control` section. The settings of the FastQC tool should appear in the middle section. A help is usually shown when you open a tool as well as the scientific literature associated with the tool for further references. For the FastQC tool we can load short read data from our history. Also a contaminant list can be uploaded (for example primers from a pre-process step can sometimes end up in the data and give all sort of problems downstream). In the submodule part of the FastQC setting you can specify which subparts of the tools need to be run. For now we are not going to bother you with settings other than the short read data.

Select <strong>Multiple Datasets</strong> under the <strong>Short read data from your current history</strong> and press <strong>Execute</strong>.

```{r, echo=FALSE, fig.align="center", out.width="80%"}
knitr::include_graphics("images/fastQCSettings.png")
```

When you clicked Execute, the jobs were started and added to the History. Each item in the history has a number which increments with one for each new item. When the jobs are finished they appear in green. When the jobs are finished, four new items have appeared in the History. If you look closely, you can see that FastQC has been run on data 1 and 2 from the History. FastQC has generated two types of reports: <strong>RawData</strong> and a <strong>Webpage</strong>. We will have a look at the Webpages for both short read data sets. Click on the **View Data** (eye-icon) for the webpage output for data 1

```{r, echo=FALSE, fig.align="center", out.width="80%"}
knitr::include_graphics("images/fastQCHistory.png")
```

In the middle panel the webpage with the results for data 1 should open. A summary of the quality checks performed is visable and gives you a quick overview of the checks that need your attention.

Report on the total number of sequences analysed, the number of sequences flagged as poor quality, the sequence length and GC percentage. Next, look at the <strong>per base sequence quality</strong>, in the plot the sequence position is plotted on the x-axis and the base quality is plotted on the y-axis. Each bar in the plot represents the distribution over all sequences analysed in your data set at this position. Also look at the Webpage from data 2 and compare the plots. Do you see any differences between the plots and would you use this data set for further analysis?

For further information on the box plot, please have a look at: <https://en.wikipedia.org/wiki/Box_plot>

```{r, echo=FALSE, fig.align="center", out.width="80%"}
knitr::include_graphics("images/fastQCPlot.png")
```

Now that we took a first look at the data and its quality, we will modify the data to make sure that we get data of the highest quality to perform our analysis on. Most likely the current data contains (many) reads of low quality or which are too short for performing the next steps. In the following two chapters we will finalize our look at the data quality by performing *read trimming* to remove these reads (or parts of reads) with low quality. Once we have a data set of acceptable quality we will perform the next and most important analysis step; *read mapping* (week 2), then we visualize the resulting mapping and perform a *pileup* operation (week 3.

As you can see in the FastQC report, the read quality drops at the end of the reads (this is normal for the Illumina protocol and has to do with the specific sequencing technology used!). `Can you find why this is happening?`

Also the spread in quality at some positions may be greater than you would like to see. In the next step we are going to remove reads that are of low quality or are just too short to be used. To make the DNA available to be sequenced, primers have been annealed to the DNA. These primers should also be removed.

From the <strong>Tools menu </strong>select the [**Trimmomatic**](http://bioinformatics.oxfordjournals.org/content/26/14/1783) tool.

-   Check if the *paired end* data is selected.
    -   Select *Pair of Datasets* as the *Input Type* (default) and select your patient R1 and R2 files.
    -   Perform an *initial IlluminaCLIP* step and select the *TruSeq3 (paired-ended, for miSeq and HiSeq)* adapters.
    -   From the *Trimmomatic operation* select the Sliding window trimming and choose 4 bases to average across, the quality should be 20 (as a minimum).
        -   Click on the plus sign (*Insert Trimmomatic Operation* button) and Select the *Drop reads below a specified length*
        -   Set the minimum read length to **70** (can you think of a reason why you do not want to have too many short reads?)
        -   Note: this is from the protocol used with the Cardiomyopathy data (paired-end 150bp reads). When using data with shorter reads (50, 75 or 100bp), change this setting accordingly (30, 40, 50 respectively).
    -   Execute the tool.

```{r, echo=FALSE, fig.align="center", out.width="80%"}
knitr::include_graphics("images/trimmomatic.png")
```

Trimmomatic will give **4** new files as output, **read** the help of the Trimmomatic tool (can be found below the tool settings in Galaxy) to understand what each file contains. For next steps in our analysis it is very important that the forward and reverse reads are in the same order in the files. If for any reason one of the forward or reverse reads was removed from one of the files, the two files will *not be in order* any more. For this reason Trimmomatic will remove both reads from the files. If one read was below the threshold and was removed, it's paired partner will be written to an unpaired output file (if it was above the threshold). In the output you will find 4 files: one for the forward paired and one for the reverse paired (these are still in order) and one for the unpaired forward and one for the unpaired reverse. Rename the two files that you will use for the next step to something like *`Trimmed Reads [ID] R1 00X`* etc.

```{css, echo = FALSE}

```

::: rmdnote
**Note on Reporting Galaxy Tool Parameters**

An important aspect of our lab journal is to document reproducible research. In order to do that, we need to properly document the tool parameters used for tools operating on our data. This is especially important for tools that modify the data, like Trimmomatic. Tools often have many parameters and we are not going to manually write down all of them. Instead, we will copy the 'Tool Parameter' table from the Galaxy tool log and paste that into our lab journal. Here is a suggestion on how to accomplish this:

-   Click on the 'i' icon in the history item for the Trimmomatic tool (named 'Dataset Details').
-   Select the complete 'Tool Parameters' table (including the header, see [this image](images/copy-tool-parameters.png) for example).
-   In RStudio, click on the 'Visual' button in the top left of your markdown document
-   Paste the copied table into the markdown document.
-   Modify the table if needed and - preferably - return to the 'Source' editor.

The final result should be similar to the table below (some rows removed):

| Input Parameter                         | Value                     |
|-----------------------------------------|---------------------------|
| Single-end or paired-end reads?         | pair_of_files             |
| Input FASTQ file (R1/first of pair)     | 3: SRR26913192_1.fastq.gz |
| Input FASTQ file (R2/second of pair)    | 1: SRR26913192_2.fastq.gz |
| ...                                     | ...                       |
| Select Trimmomatic operation to perform | SLIDINGWINDOW             |
| Number of bases to average across       | 4                         |
| Average quality required                | 20                        |
| Select Trimmomatic operation to perform | MINLEN                    |
| Minimum length of reads to be kept      | 30                        |
:::

-   Report on the **number of reads** that where removed for each data set.
    -   Create new FastQC plots of the *Per Base Sequence Quality* (on the cleaned, paired data).
    -   Compare the plots with the original uncleaned data and report on the differences.
-   Perform multiple FASTQ cleaning runs (each time on the original data!).
    -   Change a setting and report on the number of reads removed.
    -   Create and save the *Per Base Sequence Quality* plots for each run.
    -   **Report** (in a table for instance) what the effect is of each setting in the Trimmomatic tool.
    -   Pick the best (combination of) settings and copy the R1 and R2 trimmed data sets to a **new** history in Galaxy, this data will be used for the next analysis step.
    -   Please remove any unused output of Trimmomatic from the previous history, as this might take up a few gigabytes of space. If you delete these files (they can also be 'undeleted') they are just marked for actual deletion after a few months.